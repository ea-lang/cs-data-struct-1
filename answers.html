Part 1: Discussion Questions

Runtime
1. The number of non-elephant animal crackers in the box, the number of elephant crackers in the box, and the ratio between the two
2. O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n) 

Stacks and Queues
1. 1. Stack 2. Queue 3. Stack
2. Customer service, recipe
3. Packing items in a suitcase, evacuating a building 

Linked Lists
1. The nodes are the boxes containing the names of the fruit and next. The data for each node is the name of the fruit. The head is currently the node containing "Apple" and next that the head attribute is pointing to. There is no tail as the attribute has not been implemented.
2. In singly-linked lists, each node has an attribute pointing to the next node. In doubly-linked lists, the nodes additionally possess an attribute pointing to the previous node.
3. Without the tail attribute, the entire list must be traversed in order to add a new node at the end. Adding a tail attribute in order to reference the tail directly removes this burden.

Trees
1. food > Italian, Indian, Mexican > lasagna, pizza, tikka masala, saag, burritos
2. food > Italian > lasagna > pizza > thin crust > Chicago-style
3. In a binary search tree, the data in the entire tree from left to right is ordered in an ordinal ('ascending') way and each node has two children. The root divides the data in an ordinal way (e.g. by alphabetical order, by value for integers, etc.) such that all values to the right are "greater" and all values to the left are "lesser", and all subsequent nodes further sub-partition further data in this way. This makes finding a certain value in the tree a fast task because at each node's crossroads, half of the further options in the tree are eliminated. However, the tree may not preserve hierarchical meaning of the original data.